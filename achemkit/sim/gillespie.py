# -*- coding: UTF-8 -*-
#need to specify coding for greek letters in comments
"""
Module desribing a Gillspie-like mixing algorithm implementation that is a 
subclass of :py:class:`achemkit.Reactor`.

This is an approximation of a well-mixed container with continuous time. Unlike
Gibson-Bruck and similar, this does not need to know the reactions in advance.
Rather, it assumes all combiniatoric interactions are possible and tests then
as they occor.
"""


import random

import achemkit
from achemkit import Reactor
from achemkit import Event

class ReactorGillespieLike(Reactor):
    def __init__(self, achem, mols, rngseed=None, timescale=100.0):
        """
        :param achem: :py:class:`achemkit.achem.AChem` object or equivalent.
        :param mols: Initial molecular species.
        :param rngseed: Instance of :py:class:`random.Random` or seed for 
                        :py:class:`random.Random`
        :param timescale: Volume/pressure constant.
        """
        super(ReactorGillespieLike, self).__init__(achem, mols)
        self.maxtime = 0.0
        self.time = 0.0
        if isinstance(rngseed, random.Random):
            self.rng = rngseed
        else:
            self.rng = random.Random(rngseed)
        self.timescale = timescale
        self.possiblenoreactants = (2,)

    def do(self, time):
        """
        Repeatedly determine a random collection of reactants and replace them 
        with the products generated by :py:meth:`achemkit.achem.AChem.react`.
        
        :param float time: Time to simulate.
        :rtype: yields :py:class:`achemkit.Event` objects.
        """
        self.maxtime += time
        while self.time < self.maxtime:
            interval, reactants, products = self._next_reaction()
            #not enough molecules to react further
            if interval is None:
                break
            self.time += interval
            yield Event(time, reactants, products)


    def _next_reaction(self):
        """
        Internal function that calculates and applies the next reaction.
        """
        #Let the next reaction have index μ and fire at time t + τ.
        #Let α be the sum of the propensities.
        #The time to the next reaction is an exponentially distributed
        #random variable with mean 1 / α ; the probability density function
        #is P(τ = x) = α e- α x.
        #The index of the next reaction to fire is a discrete random
        #variable with probability mass function P(μ = m) = am / α.
        
        totalnumberofreactions = 0
        for noreactants in self.possiblenoreactants:
            i = noreactants
            count = len(self.mols)
            if i <= len(self.mols):
                while i > 1:
                    count *= (len(self.mols)-(i-1))
                    i -= 1
            totalnumberofreactions += count
                        
        interval = self.rng.expovariate(float(totalnumberofreactions)) * self.timescale

        noreactants = achemkit.utils.utils.get_sample(self.achem.noreactants, self.rng)
        
        if len(self.mols) >= noreactants:
            reactants = self.rng.sample(self.mols, noreactants)
            for x in reactants:
                i = self.mols.index(x)
                self.mols = self.mols[:i] + self.mols[i+1:]
            
            products = tuple(self.achem.react(reactants))
            self.mols += products
            return interval, reactants, products
        else:
            #not enough molecules left to react
            return None, None, None
                    

def sim_gillespie(achem, mols, maxtime, rng=None):
    """
    Wrapper for :py:class:`ReactorGillespieLike`.
    """
    sim = ReactorGillespieLike(achem, mols, rng)
    for e in sim.do(maxtime):
        yield e
    
